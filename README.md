# 강의
- Inflearn > 스프링부트로 직접 만들면서 배우는 대규모 시스템 설계(캐시 전략)

## 프로젝트 설정
### 레디스
- 실행
  - docker run --name cache-redis -d -p 6399:6379 redis:8.2.1
- 접속
  - docker exec -it cache-redis redis-cli
- 명령어 모음
  - 모든 키 조회
    - keys *
  - 데이터 생성
    - set mykey 'Hello Redis'
  - 데이터 조회
    - get mykey


## 개념정리
### 캐시
- 캐시란?
  - 더욱 빠른 저장소에 데이터를 보관하여, 해당 데이터에 빠르게 접근하는 기술
- 이점
  - 데이터 접근 속도 향상 
  - 저장소 부하 분산
    - ex. 레디스 같은 캐시를 사용하여 DB의 접근을 줄인다면, 부하가 분산되는 효과를 가져올 수 있다.
- Slow Storage와 Fast Storage
  - 데이터를 조회하기 위해서 대부분 Slow Storage에 접근한다.
    - 하지만 접근비용이 크고, 속도가 느리다.
    - 이를 해결하기 위해서 Slow Storage의 데이터를 Fast Storage에 캐시할 수 있다.
  - 모든 데이터를 Fast Storage에 저장하면 안되는가?
    - Fast Storage는 빠르지만 비싸다.
    - Slow Storage에 비해 안정성이 떨어진다.
    - 때문에 모든 데이터를 Fast Storage에 저장할 수는 없다.
    - 또한 파레토 법칙에 의하면, 모든 데이터를 Fast Storage에 저장할 필요도 없다.
      - 파레토 법칙
        - 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상
          - 전체 조회 트래픽의 대부분(약 80%)은 소수의 데이터(약 20%)에 집중된다. 
          - 자주 조회되는 핵심 데이터가 반복해서 읽힌다.
        - 따라서 일부 데이터만 캐시해도 효율적으로 동작한다.
- 캐시의 종류
  - Local Cache
    - 각 서버 애플리케이션 내부 메모리에 캐시
    - 매우 빠름
    - 서버 메모리 부담, 재시작 시 휘발, 데이터 일관성 관리 어려움(서버 애플리케이션 간 동기화 문제)
    - 대표 라이브러리 : Caffeine, Ehcache 등
  - Remote Cache(Global Cache)
    - 별도 서버 메모리에 캐시
    - 네트워크 통한 접근 필요하므로 Local Cache 보다 느림
    - 별도 서버 메모리에 저장하기 때문에 Local Cache 보다 큰 데이터를 장기간 저장할 수 있음
    - 여러 서버 애플리케이션이 동일한 저장소에 접근하므로 데이터 일관성 관리 유리
    - 대표 솔루션 : Redis, Memcached 등 인메모리 데이터베이스 및 라이브러리

### Redis
- Redis의 특징
  - In-memory Database
  - 고성능
  - NoSQL(Not Only SQL)
    - 관계형 데이터베이스와 달리 정해진 스키마가 없고, 유연한 데이터 모델 사용
  - 키-값 저장소
  - 다양한 자료 구조를 지원
    - String, List, Set, Sorted Set, Hash 등
  - TTL(Time To Live) 지원
    - 일정 시간이 지나면 데이터 자동 삭제
  - Single Thread
    - Redis는 단일 스레드에서 순차적으로 처리한다.
    - 각 명령어가 순차적/원자적으로 처리되므로, 동시성 문제를 해결하는데 유리하다.
  - Pub/Sub – 발행/구독 시스템
  - 데이터 백업 지원
    - 메모리는 휘발성 저장소지만, Redis에서 데이터를 디스크에 백업하는 방법도 제공(AOF, RDB)
  - Redis Cluster
    - 확장성, 부하 분산, 고가용성 등을 위한 분산 시스템 구성 방법 제공
- Redis Cluster
  - Redis의 수평 확장(Scale-Out)을 위한 기술
    - 여러 개의 Redis 서버가 클러스터를 이루면서 분산 시스템 제공
  - 고가용성, 안정성, 확장성, 부하 분산 등 다양한 이점 제공
  - 대규모 데이터와 트래픽을 다루는데 유리
  - Sharding
    - 데이터를 여러 노드에 분산하는 기술
    - 새로운 노드 추가 시 자동으로 데이터가 분산된다.
    - 확장성, 부하 분산 제공
  - Replication
    - 데이터를 복제하는 기술
    - Master 노드에 데이터를 쓰면, Replica 노드에 데이터를 복제한다.
    - 고가용성, 안정성, 부하 분산 제공

### 스프링의 캐시 애노테이션
- @Cacheable
  - Look-Aside 방식으로 동작한다.
    - 애플리케이션이 캐시를 직접 조회하고 관리한다.
    - 데이터를 읽을 때 캐시를 우선 조회하고, 데이터가 없으면(Cache Miss) DB에서 조회한 뒤 캐시에 저장하는 방식이다.
  - 동작방식
    - 캐시에서 데이터를 찾았으면, 메서드를 수행하지 않고 데이터를 반환한다.
    - 캐시에서 데이터를 찾지 못하였으면, 메서드를 수행하고 반환 값을 캐시에 저장한다.
  - Data Source의 데이터를 조회하는 메서드에 적용할 수 있다.
    - 응답된 데이터를 캐시에 저장하여, Data Source 접근을 줄일 수 있음
- @CachePut
  - 메서드를 수행하고, 반환 값을 캐시에 갱신한다.
  - 원본 데이터를 생성/수정하는 메서드에 적용할 수 있다.
- @CacheEvict
  - 메서드를 수행하고, 캐시에서 데이터를 삭제한다.
  - 원본 데이터를 삭제하는 메서드에 적용할 수 있다.
- 한계점
  - 대부분 상황에서는 캐시 애노테이션(Look-Aside 전략)으로 충분할 수 있지만, 한계점도 존재한다.
    - Cache Penetration
      - 캐시에 존재하지 않는 데이터를 반복적으로 조회하여 매번 DB까지 접근하게 되는 문제.
    - Cache Stampede
      - 캐시가 만료되는 순간 대량의 요청이 동시에 DB로 몰려 과부하가 발생하는 문제.
    - Hot Key
      - 특정 키에 요청이 집중되어 해당 캐시 서버나 DB에 부하가 쏠리는 현상.

### Cache Penetration
- Cache Penetration 이란?
  - 캐시 관통 
    - 캐시를 관통해서 Data Source로 요청이 전파되는 현상
  - 캐시 관통 흐름
    - 클라이언트가 특정 키로 조회 요청 
    - 캐시에 없음 (Cache Miss)
    - DB 조회 → 결과 없음 
    - 캐시에 저장할 값이 없으니 그대로 종료 
    - 같은 요청이 계속 들어오면 매번 DB까지 조회됨
  - 문제점
    - 캐시에서 트래픽이 제한되지 못하고, Data Source로 전파
    - Data Source가 모든 부하를 빠르게 받아내지 못한다면, 예기치 못한 장애 위험
  - 해결방법
    - Null Object Pattern
    - Bloom Filter

### Null Object Pattern
- null 데이터도 캐시에 저장  
  - 조회 결과가 없는 경우에도 `null` 대신 Null Object를 캐시에 저장하여, 동일한 요청이 반복될 때 DB 재조회 없이 캐시에서 바로 처리
- @Cacheable 메소드는 Null Object 반환  
  - 캐시 대상 메소드는 `null`을 반환하지 않고, 항상 객체를 반환하도록 설계하여 캐시 일관성을 유지
- Null Object의 기준 정의  
  - 식별자(id)가 `null`인 객체를 Null Object로 약속하여, 정상 데이터와 구분 가능하도록 설계
- 부가 정보 포함 가능  
  - 단순히 “없음”만 표현하지 않고, 상태나 메타 정보를 포함한 객체로 확장 가능
- 실패 사유 캐싱  
  - 데이터 접근 실패 원인을 함께 저장하여 재조회 없이 캐시에서 바로 판단 가능
- 유연한 사용자 응답  
  - 실제로 존재하지 않는 데이터인지, 비공개 데이터인지 등의 사유를 캐시에서 조회하여 사용자에게 안내 가능